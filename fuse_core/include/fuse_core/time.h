/*
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2020, Brett Downing
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */



/*
 * This file provides a sane configuration for a clock to manage order of events.
 * This file exists to help with a migration from fuse_core::TimeStamp to rclcpp::time
 * Priority is given to C++ std::chrono
 * emphasis will be placed on interoperability with fuse_core::TimeStamp and rclcpp::time
 *
 * This will likely be extended to distinguish between:
 *   times of events being optimised
 *   events generated by the running of the optimiser (log throttling, callbacks etc)
 *
 * The clock class will likely be overridden to prevent use of now(),
 *   emphasising that the optimiser is not strictly realtime and the epoch is probably invalid
 *
 */

#ifndef FUSE_CORE_TIME_H
#define FUSE_CORE_TIME_H

#include <chrono>
#include <iostream>
#include <stdexcept>

#include <rclcpp/clock.hpp>
#include <rclcpp/duration.hpp>
#include <rclcpp/time.hpp>


namespace fuse_core
{
using Duration = std::chrono::nanoseconds;  // rclcpp uses nanosecond durations

/**
 * @brief Implements a Time class that supports interoperability between rclcpp and std::chrono time
 *
 * The class is implemented as a thin wrapper around rclcpp::Time. This allows us to take advantage
 * of the operator overloads and clock type tracking of the parent class. Including the consistency
 * checks for clock types when doing time arithmetic.
 *
 * To support this, the internal representation of time is an rclcpp::Time object and conversion
 * functions and constructors are written to create this object out of primitive, rclcpp::Time and
 * std::chrono time objects.
 *
 * A significant deviation from rclcpp:Time is the introduction of the default constructor that
 * explicitly sets the clock type to RCL_CLOCK_UNINITIALIZED. This is done to differentiate between
 * zero-initializations of time, and an uninitialized time.
 */
class TimeStamp : public rclcpp::Time
{
  public:
    // TODO(CH3): Write docstrings for these once interfaces have stabilized
    TimeStamp();
    TimeStamp(const TimeStamp& rhs);

    TimeStamp(int32_t seconds, uint32_t nanoseconds, rcl_clock_type_t clock_type=RCL_SYSTEM_TIME);
    TimeStamp(int64_t nanoseconds, rcl_clock_type_t clock_type=RCL_SYSTEM_TIME);

    TimeStamp(const rclcpp::Time& time);
    TimeStamp(std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds>& stamp);


    rclcpp::Time to_ros() const;
    std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds> to_chrono() const;

    inline bool initialized() const {
      return this->get_clock_type() != RCL_CLOCK_UNINITIALIZED;
    }

    inline std::chrono::nanoseconds time_since_epoch() const {
      return std::chrono::nanoseconds(this->nanoseconds());
    }


    // OPERATORS ===================================================================================
    TimeStamp & operator=(const TimeStamp & rhs) = default;

    inline TimeStamp & operator=(const rclcpp::Time & time) {
      *this = TimeStamp(time);
      return *this;
    }

    inline TimeStamp & operator=(const builtin_interfaces::msg::Time & time_msg) {
      *this = TimeStamp(time_msg);
      return *this;
    }

    inline operator std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds>() const {
      return this->to_chrono();
    }
};


/**
 * @brief provide an overload for use with the ostream << operator
 *
 * Present a human readable fuse_core::TimeStamp (in nanosecond units)
 *
 * @param[in] timestamp  The rclcpp::Time to convert to print
 */
std::ostream& operator<<(std::ostream& os, const fuse_core::TimeStamp& timestamp);


/**
 * @brief Wait for time to be valid (non-zero)
 *
 * Logic adapted from: http://docs.ros.org/en/noetic/api/rostime/html/src_2time_8cpp_source.html
 *
 * @param[in] clock    An rclcpp::Clock to measure time against
 * @param[in] timeout  An optional timeout
 *
 * @param[out] valid   Whether the clock's time was valid
 */
bool waitForValid(rclcpp::Clock clock, rclcpp::Duration timeout=rclcpp::Duration(0, 0));

}

#endif  // FUSE_CORE_TIME_H
